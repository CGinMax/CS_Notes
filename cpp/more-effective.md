# More Effective笔记

## Item1 引用与指针之间的关系

在创建时，引用必须在定义时初始化，因为编译器不允许有空引用存在，即使有可能引用会使用在空指针上。

对引用重新赋值时，不会改变引用所指的对象，而是改变所指对象的储存的值。那么对指针重新赋值，会将指针指向新的对象。例如下面这段代码：

```cpp
std::string s1("hello");
std::string s2("world");
std::string& sref = s1;//sref指向s1
sref = s2;// sref还是指向s1，但s1的值为"world"
```

根据这个性质，在一些不改变对象地址的状况下返回对象值的函数，可以使用返回引用的方式实现。

## Item2 C++类型转换

主要有四大类型转换
+ static_cast<>()：基本数据类型之间的转换，编译期检查。
+ dynamic_cast<>()：有继承关系之间的转换，一般父类转子类，运行时检查。
+ const_cast<>()：消除变量的const约束，编译期检查
+ reinterpret_cast<>()：指针之间的转换。

## Item3 数组与多态的问题
根据多态的特性，父类可以由子类创建，同时，可以通过父类调用子类的虚函数，这一特性在多态中很常见，但当是一个父类数组时，则会出现错误。

由于数组在内存空间上是连续的，访问数组的元素是通过查找`首地址+元素下表i×sizeof类型`的地址。子类的size比父类的size大，父类数组被子类数组创建时，访问父类的元素则会出现地址错误，因此不能在数组中使用多态。

## Item5 避免隐式转换

当未知的隐式转换发生时，有可能产生错误的结果，一种是类的隐式类型转换运算符。直接用对象时，相当于调用了其类型转换运算符函数；一种是会将变量识别为类构造函数的参数，将该变量构造成一个类临时对象，会造成错误的结果，可以使用`explicit`关键字避免该情况的发生。

## Item6 自增运算符的区别
后缀自增（或自减）先获取当前*this的值，然后调用前缀自增（或自减），基本类型的自增（或自减）会返回const结果，如果不返回为const，则会出现i++++的现象。

## Item8 new和delete
`new`是一个以new函数名的操作符函数，一般的写法如下
```cpp
void* operator new(size_t size);
```
那么该在使用`new`关键字，创建对象时，编译器会将该过程解释为
```cpp
// new关键字操作
Cls newObj = new Cls(SIZE);
// 编译器操作
Cls obj = operator.new(SIZE);
Cls newObj = static_cast<Cls*>(obj);
```

同样`delete`操作编译器也会对其进行展开
```cpp
// delete关键字操作
delete obj;
// 编译器操作
obj->~Cls();
operator delete(obj);
```

数组的new采用`operator new[]`。

## Item9 通过析构释放资源

## Item10 在构造函数中防止资源泄露
内存分配是由`new`关键字运作，如果new操作抛出了异常，在构造函数使用new且遇到了异常，是无法通过对该对象进行delete删除所分配的内存，有效的方法是在构造函数中捕获异常，并删除new操作后的数据。